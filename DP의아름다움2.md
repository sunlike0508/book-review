# DP의 아름다움2

## Prodecure Oriented 프로시져 지향

절차적 지향? 아니다 번역이 잘못됌.

프로시져 -> 상태와 상태를 변화시키는 명령을 분리하여 생각함.

상태란 명령 흐름에 따라 계속 변화하고 최종 결론에 도달.

상태를 변경하는 흐름에 나눠서 문제를 분할함.

**노이만머신 프로그래밍 그 자체. 프로시저란 이거를 추상화 시킨 것**

그래서 분기나 반복 등 복잡한 흐름이 집합 수준에서 생기면 통제가 어려워짐.

상태는 결과적, 로그가 없음. 디버깅시 별도로깅. 시간 흐름이 중요.

결국 시간이 정말로 중요. 시간의 흐름에 따라서 결과가 정해짐.

질문 ? 근데 객체지향이라는 것도 상태라는 것을 가지고 있고 이것도 결국 시간의 흐름에 따라서 결과가 바뀌는데 무슨 차이가 있는가?

상태변화는 결과적이지만, 상태가 격리되어 상태를 컨트롤할수 있는게 딱 하나의 객체로만 정해져 있다. 즉, 책임소재가 확실하기 때문에 프로시져 지향보다 대규모 프로젝트에 적합하다.
(단, 정보은닉, 캡슐화가 잘되어 있다는 가정. 당연히도 이게 깨짐 객체 지향이라고 할 수가 없다.)


## setter를 통한 DI 대응은 어디까지 용서해야 하는가?

1. 애노테이션 프로세서 등 컴타임 타임 플러그인 의존만 허용.
2. 지연 할당을 위한 런타임 DI 대응을 위해 코딩 규약을 쓰자.

## Convert 함수

엔티티를 레포로 가져와서 비즈니스 옵젝으로 변경하는것? 도대체 무엇임?

1. walletBO = walletEntity.convert(); = 컨버터는 엔티티꺼야
  * 레포가 도메인에 맞춰 끼워 넣어줌
  * 도메인을 레포에 의존하지 않고 애플리케이션에서 주도
  * 그럼 누가 변하고 누가 안변하는건가?
  * 엔티티는 변하는데 BO는 변하지 않는다. 왜?
  * 애플리케이션에서 중심의 도메인은 모두 BO가 가지있어 튼튼하고 엔티티는 물리계층에 있기 때문에 효율적으로 계속해서 바꿀수 있다.
  * 유지보수 입장에서는 BO가 애플리케이션에서 더 많이 활약할수록 엔티티의 역할은 하찮기 때문에 유지보수가 쉽다.
2. walletBO = new WalletBO().convert(walletEntity); = 컨버터는 비즈니스 옵젝이야
  * 도메인이 레포를 해석함
  * ERD등이 도메인 중심인 경우 고래해볼만함
4. walletBO = walletService.convert(walletEntity); = 컨버터는 서비스꺼야.
  * 프로젝트가 보다 대규모라 레포와 도메인 양쪽을 중계하는게 더 효율적인 경우는 고려해볼만 함.

즉, 컨버터를 가지고 있는쪽이 오히려 변화에 대응하기 쉽다. 컨버터를 당하는 쪽이 딱딱하고 유지보수가 어렵다.

질문 : 컨버터는 그냥 타입을 변경해주는 간단한 작업이라고 생각하는데 무슨 차이임? 

답: 맴버 row ID기준을 하는 테이블을 가지고 가정. ERD 중심으로 광범위한 로그인이라고 생각해보자. 맴버테이블 유효ID만 발급하고 이 유효 ID를 물고 있는

페이스북 로그인테이블, 이메일 로그인테이블, 아이디패스워드 로그인테이블 나눠서 ERD로 내렸다고 가정하자. 

그러면 엔티티의 내용이 완전히 달라짐. 이걸 수용한 맴버BO를 만들어야함.

거꾸로 도메인 중심. 맴버테이블이 정규화되어 5개로 되었든, 아니면 하나로만 이루어졌든 우리는 맴버 BO 하나만 만들면 돼. 

BO가 확고할수록 엔티티 레이어는 변화를 할 수가 없음. 그리고 도메인에 관여할 수 없음. 점점 데이터 저장소로 변함.

정규화할수록 엔티티와 레포의 변경이 도메인에 점점 관여. 엔티티의 변화가 비즈니스 전체의 변화를 일으킴

맹기완님 개인적 의견 : 나는 풍부한 도메인을 별로 좋아하지 않음. -> 시간이 흐를수록 사람도 바뀌고 요구사항도 바뀌기 때문에 유지보수 측면에서 잘 안되기 때문에. 그래서 그냥 ERD 모델로 하는게 나을수도 있다.


## 서비스의 책임

프로시져 지향에서는 서비스가 객체의 상태를 책임졌다면 객체지향에서는 객체가 자신의 상태를 책임진다.

어디까지 서비스가 중계해야 하는가? 고민해보자....

1. 간이 DI로 동작하고 객체 간 협력은 각 객체에서 구현. 미디에이터, 진입점, 컨테이너 수준
2. 변환, 메시지 중계, 중간 상태 관리, 트랜잭션 중계등 협력 구현 퍼사드, 프로시져 지향
3. 협력은 각 객체가 구현하고 의존성은 DI컨테이너가 처리. 서비스는 진입점 역할 및 로깅 등 별도의 관심사만 처리하기 위해 존재

위와 같은 역할들이 있을 수도 있다.

풍성한 도메인 모델은 해당 모델에서 도메인 지식과 처리 단계를 소유하므로 역할을 축소키킴.


## 풍성한 도메인 모델과 RDB

1. SQL(쿼리)는 곧 ERD의 결과임, 따라서 빈약한 도메인 모델은 정규화된 ERD 구조에 의존하는 서비스라 간접적으로 시사함.
2. 풍성한 도메인은 주요 로직이 애플리케이션에 탑재되므로 이론상 저장소는 어떤 구조로 가져도 상관없고 도메인 모델을 잘 저장할수만 있으면 됨

**풍성한 도메인 모델을 쓰면서 정교하게 모델링 된 ERD와의 관계를 어떻게 설정할 것인가?**

에시) ENUM을 ERD로 넣을것인가

엔티티는 객체가 아니다. 그냥 구조일뿐. 그래서 은식할 필요도 없음. 그냥 순수 데이터. 

근데 BO는 반대. 객체. 정보은닉해야함. 그래서 애를 밖에서 내장을 까려고 하면 안됌. 그래서 위에 2번 BO가 엔티티를 받아서 convert하는게 나은 경우가 많다.

## 추상클래스와 인터페이스

1. 추상클래스는 (구현타입과) 격리된 상태를 추가로 사용함.
   * private을 제외한 속성이나 메소드에 의존하면 프로시져 지향. 왜냐하면 자식이 부모클래스의 속성이나 메소드를 건드릴수 있으니까
   * 상속이 나쁜게 아닌데 상속이 나쁜 이유는 super키워드와 pivate이 아닌 속성을 가능하게 해주는 가시성이다. -> 이거 두개 모두 불가능한게 인터페이스
   * 상태를 사용하지 않는 추상층의 메소드는 보통 유틸 함수임 -> this가 필요하면 메소드 this가 필요없으면 static 유틸 메소드
   * 따라서 템플릿 패턴을 추천
   * 격리 상태 기반의 메소드는 결국 별도 전략객체로 분리가능 -> 추상클래스의 private 메소드는 결국 별도의 객체로 나온다. 굳이 추상클래스를 부모로 둘 필요는 없다.
   * 그래서 추상클래스가 존재해야하는 이유는 타입계층을 만들어서 강제허거나, 템플릿 메소드 패턴 쓸때만 쓴다
   * 결국 타입 계층을 이용할 것이냐 말것이냐 가장 중요한 문제
  
2. 추상클래스는 계층이 무한히 깊어질 수 있음.
   * 계층이 깊어지면 각 층을 이해해야 함 (프레임워크를 공부하기 어려운 이유...)
   * 새 기능 추가 시 적합한 계층을 판정해야 함.

3. 인터페이스는 깊어지지 않고 넓어짐
   * 구상클래스를 기능 단위로 분해해서 사용함(SPR 위반위험) -> 한 클래스가 여러 인터페이스(하나의 책임을 가지고 있음) implement를 하면 SRP 위반 아님?
   * 구현은 조합이 가능하지만 사용 시 조합 문제

```text
interface A{};
interface B{}:
interface C{}:

class ABC{}; // 개념적으로 A,B, C를 가진 하나의 클래스

fun <T> get() T where T:A, T:B
fun <T> set(v:T) where T:A, T:C
```
내가 리턴하은 값이 싶은 A이면서 B야 혹은 내가 받고 싶은 인자가 A이면서 C야. 어떡함?
그래서 

class AB: A, B
class AC: A, C

이렇게 늘어남. 실제 intersaction type을 지원하지 않으면 결국 인터페이스 조합만큼의 구상타입을 만들어야 함. 현실적으로 인터페이스 기반으로 기능 분리하기가 어려움.

그래서 실제 상속을 지양하고 합성과 위임을 권장함.

## 상향식 하향식

















